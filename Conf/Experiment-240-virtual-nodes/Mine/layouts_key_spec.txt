s_p_options_t entity_options[] = {
	/* base keys */
	{"BitmapPosition", S_P_UINT32},  // Bitmap position or Array Index correlation, This is used for conversion from Layout to Bitmap
//	{"Selected", S_P_BOOLEAN},
	{"AllocatedNodeCount",S_P_UINT32}, // Selected,Allocated separate list is possible
	{"AllocatedSocketCount",S_P_UINT32},
	{"AllocatedCoreCount",S_P_UINT32},
	
	/* Non-Aggregated keys and used for aggregation */
	{"nodecount",S_P_UINT32},  // It is for SUM from child , And it shoud be "1"
	{"socketcount",S_P_UINT32},  // It is for SUM from child , And it shoud be "1"
	{"corecount",S_P_UINT32},  // It is for SUM from child , And it shoud be "1"
	{"ThreadsPerCore",S_P_UINT32},  // RD_ONLY value never Change.In the core entity only

	/* Selected cores,sockets,nodes information */
	{"SelectedNodeCount",S_P_UINT32}, // Selected,Allocated separate list is possible
	{"SelectedSocketCount",S_P_UINT32},
	{"SelectedCoreCount",S_P_UINT32},

	
//	{"NodeState",S_P_LONG},   // In Node level only. If NodeState is drained change count to zero.
	
//	{"NumParts",S_P_UINT32},   // In root level only, If the LAYOUT_STRUCT_TREE is used partition will not be addable.
//	{"PartitionPriority",S_P_UINT32},   //If Graph struct_type in the Layout use Partition virtual entity
		
//  {"FreeMemory", S_P_UINT32}, // In node level only
	
//	{"ForWhatPurposePriority",S_P_UINT32}, // Fir What reason selected. if we have multiple Reason 
		
	/* After Allocation  */
	
//  {"AllocatedMemory", S_P_UINT32},
//	{"AllocatedJobID", S_P_UINT32},
//	{"JobIdList",S_P_ARRAY},

	/* Parents aggregated keys */
	
	{"NumSumNodes", S_P_UINT32},  // It is in Cluster
	{"NumSumCoresInCluster",S_P_UINT32},
	{"NumSumSocketsInCluster",S_P_UINT32},
	{"NumSumSockets",S_P_UINT32}, // It is in Node
	{"NumSumCoresInNode",S_P_UINT32},
	{"NumSumCores",S_P_UINT32}, //It is in Socket
//  {"NumSumThreadsInCluster",S_P_UINT32}  // If CR_THREAD LEVEL
	
	{"SelectedSumNodes", S_P_UINT32},  // It is in Cluster
	{"SelectedSumCoresInCluster",S_P_UINT32},
	{"SelectedSumSocketsInCluster",S_P_UINT32},
	{"SelectedSumSockets",S_P_UINT32}, // It is in Node
	{"SelectedSumCoresInNode",S_P_UINT32},
	{"SelectedSumCores",S_P_UINT32},	//It is in Socket
	
	{"AllocatedSumNodes", S_P_UINT32},  // It is in Cluster
	{"AllocatedSumCoresInCluster",S_P_UINT32},
	{"AllocatedSumSocketsInCluster",S_P_UINT32},
	{"AllocatedSumSockets",S_P_UINT32}, // It is in Node
	{"AllocatedSumCoresInNode",S_P_UINT32},
	{"AllocatedSumCores",S_P_UINT32}, //It is in Socket

	for( i=0; i<switch_levels; i++)
	{
		{selected_node_cnt[i][30],S_P_UINT32},
		{selected_cpu_cnt[i][30],S_P_UINT32},
		{num_node_cnt[i][30],S_P_UINT32},
		{num_cpu_cnt[i][30],S_P_UINT32},
		{num_core_cnt[i][30],S_P_UINT32},
		{num_socket_cnt[i][30],S_P_UINT32},
		{allocated_node_cnt[i][30],S_P_UINT32},
		{allocated_core_cnt[i][30],S_P_UINT32},
		{allocated_socket_cnt[i][30],S_P_UINT32},
		{allocated_cpu_cnt[i][30],S_P_UINT32},
	}

	{NULL}
        
};
s_p_options_t options[] = {
	{"Entity", S_P_EXPLINE, NULL, NULL, entity_options},
	{NULL}
};

const layouts_keyspec_t keyspec[] = {
	/* base keys */
   	{"BitmapPosition", L_T_UINT32},  // Bitmap position or Array Index correlation, This is used for conversion from Layout to Bitmap
	{"Selected", L_T_BOOLEAN},
	{"AllocatedNodeCount",L_T_UINT32,KEYSPEC_UPDATE_CHILDREN_MASK,"AllocatedSocketCount"}, // Selected,Allocated separate list is possible
	{"AllocatedSocketCount",L_T_UINT32,KEYSPEC_UPDATE_CHILDREN_MASK,"AllocatedCoreCount"},
	{"AllocatedCoreCount",L_T_UINT32},
//	{"AllocatedJobID", L_T_UINT32},
	
	/* Non-Aggregated keys and used for aggregation */
	{"nodecount",L_T_UINT32},  // It is for SUM from child , And it shoud be "1"
	{"socketcount",L_T_UINT32},  // It is for SUM from child , And it shoud be "1"
	{"corecount",L_T_UINT32},  // It is for SUM from child , And it shoud be "1"
	{"ThreadsPerCore",L_T_UINT32},  // RD_ONLY value never Change.In the core entity only
/* Selected cores,sockets,nodes information */
	{"SelectedNodeCount",L_T_UINT32}, // Selected,Allocated separate list is possible
	{"SelectedSocketCount",L_T_UINT32},
	{"SelectedCoreCount",L_T_UINT32},
	
//	{"NodeState",S_P_LONG},   // In Node level only. If NodeState is drained change count to zero.
	
//	{"NumParts",S_P_UINT32},   // In root level only, If the LAYOUT_STRUCT_TREE is used partition will not be addable.
//	{"PartitionPriority",S_P_UINT32},   //If Graph struct_type in the Layout use Partition virtual entity
		
//  {"FreeMemory", S_P_UINT32}, // In node level only
	
//	{"ForWhatPurposePriority",S_P_UINT32}, // Fir What reason selected. if we have multiple Reason 
		
	/* After Allocation  */
	
//  {"AllocatedMemory", S_P_UINT32},
//	{"AllocatedJobID", L_T_UINT32},
//	{"JobIdList",S_P_ARRAY},

	/* Parents aggregated keys */
	
	{"NumSumNodes", L_T_UINT32, KEYSPEC_UPDATE_CHILDREN_SUM, "nodecount"},  // It is in Cluster
	{"NumSumCoresInCluster",L_T_UINT32, KEYSPEC_UPDATE_CHILDREN_SUM, "NumSumCoresInNode"},
	{"NumSumSocketsInCluster",L_T_UINT32, KEYSPEC_UPDATE_CHILDREN_SUM, "NumSumSockets"},
	{"NumSumSockets",L_T_UINT32, KEYSPEC_UPDATE_CHILDREN_SUM, "socketcount"}, // It is in Node
	{"NumSumCoresInNode",L_T_UINT32, KEYSPEC_UPDATE_CHILDREN_SUM, "NumSumCores"},
	{"NumSumCores",L_T_UINT32, KEYSPEC_UPDATE_CHILDREN_SUM, "corecount"}, //It is in Socket
//  {"NumSumThreadsInCluster",S_P_UINT32}  // If CR_THREAD LEVEL

/*Free Nodes, Cores details inserted in the beginning aftewards value change update */
	{"SelectedSumNodes", L_T_UINT32, KEYSPEC_UPDATE_CHILDREN_SUM, "SelectedNodeCount"},  // It is in Cluster
	{"SelectedCoresInCluster",L_T_UINT32, KEYSPEC_UPDATE_CHILDREN_SUM, "SelectedSumCoresInNode"},
	{"SelectedSumSocketsInCluster",L_T_UINT32, KEYSPEC_UPDATE_CHILDREN_SUM, "SelectedSumSockets"},
	{"SelectedSumSockets",L_T_UINT32, KEYSPEC_UPDATE_CHILDREN_SUM, "SelectedSocketCount"}, // It is in Node
	{"SelectedSumCoresInNode",L_T_UINT32, KEYSPEC_UPDATE_CHILDREN_SUM, "SelectedSumCores"},
	{"SelectedSumCores",L_T_UINT32, KEYSPEC_UPDATE_CHILDREN_SUM, "SelectedCoreCount"},	//It is in Socket
	
	{"AllocatedSumNodes", L_T_UINT32, KEYSPEC_UPDATE_CHILDREN_SUM, "AllocatedNodeCount"},  // It is in Cluster
	{"AllocatedSumCoresInCluster",L_T_UINT32, KEYSPEC_UPDATE_CHILDREN_SUM, "AllocatedSumCoresInNode"},
	{"AllocatedSumSocketsInCluster",L_T_UINT32 ,KEYSPEC_UPDATE_CHILDREN_SUM ,"AllocatedSumSockets"},
	{"AllocatedSumSockets",L_T_UINT32, KEYSPEC_UPDATE_CHILDREN_SUM ,"AllocatedSocketCount"}, // It is in Node
	{"AllocatedSumCoresInNode",L_T_UINT32, KEYSPEC_UPDATE_CHILDREN_SUM, "AllocatedSumCores"},
	{"AllocatedSumCores",L_T_UINT32, KEYSPEC_UPDATE_CHILDREN_SUM, "AllocatedCoreCount"}, //It is in Socket

	for( i=0; i<switch_levels; i++)
	{
		if( i == 0 )
		{
			{selected_node_cnt[i],L_T_UINT32},
			{selected_cpu_cnt[i],L_T_UINT32},
			{num_node_cnt[i],L_T_UINT32},
			{num_cpu_cnt[i],L_T_UINT32},
			{num_core_cnt[i],L_T_UINT32},
			{num_socket_cnt[i],L_T_UINT32},
			{allocated_node_cnt[i],L_T_UINT32},
			{allocated_core_cnt[i],L_T_UINT32},
			{allocated_socket_cnt[i],L_T_UINT32},
			{allocated_cpu_cnt[i],L_T_UINT32},
		}
		else
		{
			{selected_node_cnt[i],L_T_UINT32},
			{selected_cpu_cnt[i],L_T_UINT32},
			{num_node_cnt[i],L_T_UINT32},
			{num_cpu_cnt[i],L_T_UINT32},
			{num_core_cnt[i],L_T_UINT32},
			{num_socket_cnt[i],L_T_UINT32},
			{allocated_node_cnt[i],L_T_UINT32},
			{allocated_core_cnt[i],L_T_UINT32},
			{allocated_socket_cnt[i],L_T_UINT32},
			{allocated_cpu_cnt[i],L_T_UINT32},
		}
	}

	{NULL}
};






int init(void)
{
	char selected_node_cnt[switch_levels][30],selected_cpu_cnt[switch_levels][30],num_node_cnt[switch_levels][30],
	num_cpu_cnt[switch_levels][30],num_core_cnt[switch_levels][30],num_socket_cnt[switch_levels][30],
	allocated_node_cnt[switch_levels][30],allocated_core_cnt[switch_levels][30],allocated_socket_cnt[switch_levels][30],
	allocated_cpu_cnt[switch_levels][30];

	int nb_of_options_entity, i, j;
		
	info("L-CONS-RES-PARTITION initialization was started");

	int nb_of_base_options = 40 ;
	int nb_of_switch_options = 10;

	s_p_options_t entity_options_tmp[] = {
		/* base keys */
		{"BitmapPosition", S_P_UINT32},  // Bitmap position or Array Index correlation, This is used for conversion from Layout to Bitmap
	//	{"Selected", S_P_BOOLEAN},
		{"AllocatedNodeCount",S_P_UINT32}, // Selected,Allocated separate list is possible
		{"AllocatedSocketCount",S_P_UINT32},
		{"AllocatedCoreCount",S_P_UINT32},
	
		/* Non-Aggregated keys and used for aggregation */
		{"nodecount",S_P_UINT32},  // It is for SUM from child , And it shoud be "1"
		{"socketcount",S_P_UINT32},  // It is for SUM from child , And it shoud be "1"
		{"corecount",S_P_UINT32},  // It is for SUM from child , And it shoud be "1"
		{"ThreadsPerCore",S_P_UINT32},  // RD_ONLY value never Change.In the core entity only

		/* Selected cores,sockets,nodes information */
		{"SelectedNodeCount",S_P_UINT32}, // Selected,Allocated separate list is possible
		{"SelectedSocketCount",S_P_UINT32},
		{"SelectedCoreCount",S_P_UINT32},

	
	//	{"NodeState",S_P_LONG},   // In Node level only. If NodeState is drained change count to zero.
	
	//	{"NumParts",S_P_UINT32},   // In root level only, If the LAYOUT_STRUCT_TREE is used partition will not be addable.
	//	{"PartitionPriority",S_P_UINT32},   //If Graph struct_type in the Layout use Partition virtual entity
		
	//  {"FreeMemory", S_P_UINT32}, // In node level only
	
	//	{"ForWhatPurposePriority",S_P_UINT32}, // Fir What reason selected. if we have multiple Reason 
		
		/* After Allocation  */
	
	//  {"AllocatedMemory", S_P_UINT32},
	//	{"AllocatedJobID", S_P_UINT32},
	//	{"JobIdList",S_P_ARRAY},

		/* Parents aggregated keys */
	
		{"NumSumNodes", S_P_UINT32},  // It is in Cluster
		{"NumSumCoresInCluster",S_P_UINT32},
		{"NumSumSocketsInCluster",S_P_UINT32},
		{"NumSumSockets",S_P_UINT32}, // It is in Node
		{"NumSumCoresInNode",S_P_UINT32},
		{"NumSumCores",S_P_UINT32}, //It is in Socket
	//  {"NumSumThreadsInCluster",S_P_UINT32}  // If CR_THREAD LEVEL
	
		{"SelectedSumNodes", S_P_UINT32},  // It is in Cluster
		{"SelectedSumCoresInCluster",S_P_UINT32},
		{"SelectedSumSocketsInCluster",S_P_UINT32},
		{"SelectedSumSockets",S_P_UINT32}, // It is in Node
		{"SelectedSumCoresInNode",S_P_UINT32},
		{"SelectedSumCores",S_P_UINT32},	//It is in Socket
	
		{"AllocatedSumNodes", S_P_UINT32},  // It is in Cluster
		{"AllocatedSumCoresInCluster",S_P_UINT32},
		{"AllocatedSumSocketsInCluster",S_P_UINT32},
		{"AllocatedSumSockets",S_P_UINT32}, // It is in Node
		{"AllocatedSumCoresInNode",S_P_UINT32},
		{"AllocatedSumCores",S_P_UINT32}, //It is in Socket

		{NULL}
        
	};

if(switch_levels > 0)
{
	nb_of_switch_options *= switch_levels;
	nb_of_switch_options += nb_of_base_options;
	xrealloc(entity_options_tmp,sizeof(s_p_options_t) * nb_of_switch_options);
	for( i=0; i < switch_levels; i++)
	{
		sprintf(selected_node_cnt[i],"%s%d",L_SELECTED_NODE_CNT,i);
		sprintf(selected_cpu_cnt[i],"%s%d",L_SELECTED_CPU_CNT,i);
		sprintf(num_node_cnt[i],"%s%d",L_NUM_NODE_CNT,i);
		sprintf(num_cpu_cnt[i],"%s%d",L_NUM_CPU_CNT,i);
		sprintf(num_core_cnt[i],"%s%d",L_NUM_CORE_CNT,i);
		sprintf(num_socket_cnt[i],"%s%d",L_NUM_SOCKET_CNT,i);
		sprintf(allocated_node_cnt[i],"%s%d",L_ALLOCATED_NODE_CNT,i);
		sprintf(allocated_core_cnt[i],"%s%d",L_ALLOCATED_CORE_CNT,i);
		sprintf(allocated_socket_cnt[i],"%s%d",L_ALLOCATED_SOCKET_CNT,i);
		sprintf(allocated_cpu_cnt[i],"%s%d",L_ALLOCATED_CPU_CNT,i);
	}

	for( j=i=nb_of_base_options; i<switch_levels && i <= nb_of_switch_options; i++,j+=10)
	{
		entity_options_tmp[j]={{selected_node_cnt[i][30],S_P_UINT32}};
		entity_options_tmp[j+1] = {selected_cpu_cnt[i][30],S_P_UINT32};
		entity_options_tmp[j+2] = {num_node_cnt[i][30],S_P_UINT32};
		entity_options_tmp[j+3] = {num_cpu_cnt[i][30],S_P_UINT32};
		entity_options_tmp[j+4] = {num_core_cnt[i][30],S_P_UINT32};
		entity_options_tmp[j+5] = {num_socket_cnt[i][30],S_P_UINT32};
		entity_options_tmp[j+6] = {allocated_node_cnt[i][30],S_P_UINT32};
		entity_options_tmp[j+7] = {allocated_core_cnt[i][30],S_P_UINT32};
		entity_options_tmp[j+8] = {allocated_socket_cnt[i][30],S_P_UINT32};
		entity_options_tmp[j+9] = {allocated_cpu_cnt[i][30],S_P_UINT32};
	}
	
}
	entity_options = entity_options_tmp;
	return SLURM_SUCCESS;
}

